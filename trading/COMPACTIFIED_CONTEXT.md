# Compactified Context

## Gates, regimes, and posture
- Phase-4 density monitor (see `scripts/phase4_density_monitor.py`, profile `configs/phase4_monitor_profiles.json`) enforces: per-ontology balance ≥25%, bin persistence ≥6/8, ≥40 rows/bin, monotonic medians, effect-size ≥0.0005. Gate success requires 3 consecutive OPENs; each iteration logs `blocking_reason` in `logs/phase4/density_monitor.log` and JSON outputs.
- Phase-07 asymmetry density: `edge = x_{t-1} * Δm_t`, `cost = (h_t + f_t) * m_t * |Δx_t|`, `rho_A = Σ edge / (Σ cost + eps)`. Phase-04 only unblocks when `rho_A` clears threshold with persistence, no special codes, and survives small execution perturbations to avoid false eigen-events.
- Control-law clarifications: UNKNOWN/M5 means HOLD (buffer), not forced FLAT; profit eigen-events require surviving boundary costs and special-code escalation (VOID/PARADOX). Gate-first hazard semantics (“all-red spine” / Meta-Witness) guard exposure before commitment.
- Kernel/regulator outputs triadic posture (-1 Hostile, 0 Tense, +1 Coherent); posture_observe documents the observe-only path in Phase-6 gating (`docs/stream_daemon.md`, `docs/phase6_capital_control.md`, `docs/posture_observe_notes.md`). Minimal profitable architecture = triadic condition classifier → cheap strategy layer (only when +1) → execution/risk clamps. Sense fast, commit slow (per-second sensing; minute/hour commitment).
- Live gate invariant: closed Phase-6 gate forces `posture_observe` (`direction=0`, `target_exposure=0`, `hold=true`, `actionability=0`), so Phase-07 is empty; only a `capital_controls_*.jsonl` with `allowed=true` wakes the stack. Decision payloads now carry `phase6_gate` snapshots (`open`, `source`, `allowed_slip_bps`, `reason`) for refusal diagnostics; recommended wake-up proof is to inject a slip approval and restart the live daemon.
- Live Phase-07 finding: with gate open and coherent posture, the controller ramped long exposure every 1–3s (e.g., NEOUSDT), giving non-empty support, but Phase-07 net stayed ≤0 because boundary costs dominate at that cadence (noise-scale returns vs cost on each Δx). This is a boundary-dominated eigen-orbit, not a wiring bug. Experiments: lift horizon to 30–120s with cost on entry/exit, run zero-cost sanity to confirm wiring, and align actuation/measurement (slower clock, batched/impulse changes, or charge cost only on sign flips/regime exits).
- Phase-8 intent (net-surplus gate): trade only when Phase-07 shows the action stream (actuator + horizon + costs) is net extractable on live logs. Prereqs: Phase-7.1 actuator testability (decimation/impulse in live daemon), Phase-7.2 live execution ledger in Phase-07 schema, Phase-7.3 horizon sweep harness (10–300s) to locate any positive net density. Entry gate: actuator mode fixed/logged; Phase-07 ready persists; boundary gate clamps when ready=false; one-command audit reports net/gross density, activity rate, cost vs move share, worst drawdown.
- Phase-9 intent (certified operator): capital becomes a state variable; multi-regime certification proves profitability in ≥1 regime and preservation elsewhere; learning is capital-budgeted; Meta-Witness can freeze or force OBSERVE; every action stores a justification chain. Success = unattended operation with automatic throttles, refusals, and justification artifacts. See `docs/phase9_legitimacy.md`.
- Phase-8 intent (net-surplus gate): trade only when Phase-07 shows the action stream (actuator + horizon + costs) is net extractable on live logs. Prereqs: Phase-7.1 actuator testability (decimation/impulse in live daemon), Phase-7.2 live execution ledger in Phase-07 schema, Phase-7.3 horizon sweep harness (10–300s) to locate any positive net density. Entry gate: actuator mode fixed/logged; Phase-07 ready persists; boundary gate clamps when ready=false; one-command audit reports net/gross density, activity rate, cost vs move share, worst drawdown.
- Dual-kernel tension (M6): Kernel A = legitimacy/structural health; Kernel B = exploitability/forced behavior. Joint posture guidance: Stable+Edge → normal trade; Tense+Edge → asymmetric/small/convex; Hostile+Edge → convex-only; any/no edge → HOLD/BAN. Choppy or contradictory regimes should default to inactivity.

## Learner / ℓ contract
- Non-negotiable: learner never sets direction/size. It outputs legitimacy scalar ℓ∈[0,1] plus qfeat; triadic gate/hysteresis (`θ_on/θ_off`, `τ_on/τ_off`) uses ℓ only for permission (ACT/HOLD/BAN unchanged). Adapter must be called every bar in `confidence_fn` and logs should include `ell` and `legitimacy_margin` for replay diagnostics.
- Training objective is PnL-free: predict quotient invariants and set `ℓ = exp(-|v̂_{t+1} - v_{t+1}|)`; optional anti-chatter regularizer. Success criteria: ACT rate drops in bad regimes, lower tail risk/variance, existing edge preserved. Use correlated-shock windows (e.g., mid-2015 multi-asset spike) to validate HOLD behavior.
- Integration steps (locked from Step-3 sign-off): stub adapter + hysteresis are stable; Step-4 = replace stub ℓ with real qfeat on CPU, rerun hysteresis/acceptability plots, calibrate ℓ distribution before touching PnL. Keep BAN logic untouched; add optional `adapter.supports_gpu` flag for backend swap.
- Operational backtests: force posture −1/0 → flat, +1 → allow; compare against always-on baseline; slow trading clock; only refine tension/posture states after gating proves capital preservation.

## qfeat + GPU/Vulkan contract
- Frozen qfeat vector order (dimensionless, shift/scale invariant): `[vol_ratio, curvature, drawdown, burstiness, acorr_1, var_ratio]`. CPU reference (`compute_qfeat`, w1=64, w2=256, EPS=1e-6) uses log returns, std/range vol ratio, log std of second differences, normalized drawdown, L1/L2 burstiness, clipped lag-1 autocorr, fast/slow variance ratio; NaN/Inf squashed to 0.
- GPU/CPU split: GPU computes window→qfeat (and later qfeat prediction + ℓ); CPU handles hysteresis/regime gating, logging, and BAN logic. Only ℓ (plus tiny debug vector if enabled) crosses GPU→CPU. Keep learner PnL-free online; retrain from logged qfeat streams.
- Parity harness: `python tools/parity_qfeat.py --tape logs/qfeat_tape.memmap --backend vulkan --force --w2 16 --w1 4` and keep worst diffs ≤2e-4 before shader edits. Shader boundary lives at `vulkan_shaders/qfeat.comp`; parity helper in `tools/parity_qfeat.py`; Vulkan adapter scaffolding in `trading/vk_qfeat.py` and `trading/strategy/vulkan_tape_adapter.py`.
- GPU implementation order: freeze window→sheet→qfeat path, add ℓ on GPU, wire ℓ into gate (CPU), backtest for ACT suppression in bad regimes, then add small predictor head if needed. Keep CPU fallback for determinism.

## Tape/replay workflow
- `scripts/run_with_vulkan_tape.py --force` rebuilds qfeat tape and overwrites slot 6 (ℓ); add/use `--reuse-tape` to replay without rebuilding (should not require `--prices-csv` when reusing). Default = build if missing; `--force` = rebuild; `--reuse-tape` = error if tape absent.
- Replays/plots: ensure `ell`/`legitimacy_margin` columns are written so acceptability/hysteresis plots show real signal; avoid caching confidence outside the adapter.

## Stream/monitoring anchors
- Stream daemon (`scripts/stream_daemon.py`/`docs/stream_daemon.md`) emits triadic decisions with Phase-6 gating, supports sinks (NDJSON, TCP fan-out, latest-action view), probe mode, and live plotting/timelapse via `scripts/stream_daemon_live.py` and `scripts/plot_stream_decisions.py`; dashboard variants add fee-aware metrics and posture overlays.
- Phase-5 execution simulator (`scripts/phase5_execution_simulator.py`) consumes proposals+prices and reports `realized_pnl`, `slippage_cost`, `execution_cost`; use for backtests without PnL feedback into ℓ.
- ES/NQ ingestion plan (`docs/es_nq_ingestion_plan.md`, `scripts/check_esnq_ingestion.py`) provides 5-minute artifacts; monitors flag ES/NQ gates as OPEN after strict profile persistence. Use `python data_downloader.py` for refreshes; `--test-vector` tags amplitude-injected runs.
